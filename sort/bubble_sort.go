package main
import "fmt"

func bubbleSort(arr []int) {
  length := len(arr)
  for i:=0; i<length-1; i++{
    // 我这样写也对,但是是不对的
    //for j:= 1;j<length-2; j++{
    for j:= 1; j<length-i-1; j++{
      if arr[j] > arr[j+1] {
        arr[j], arr[j+1] = arr[j+1], arr[j]
      }
    }
  }

}

func main() {
  arr := []int{2, 6, 22, 44, 23, 21, 29}
  bubbleSort(arr)
  fmt.Println(arr)

}
// 在冒泡排序算法中，每一轮外部循环将会将当前未排序部分的最大元素冒泡到正确的位置。
// 在每次内部循环中，比较相邻的两个元素，并将较大的元素交换到右侧。
// 每次内部循环结束后，未排序部分的最大元素都会“冒泡”到已排序部分的末尾。

// 在第一轮外部循环结束后，未排序部分的最大元素已经被移动到了切片的最后一个位置（即 arr[length-1]）。
// 在第二轮外部循环结束后，未排序部分的次大元素已经被移动到了倒数第二个位置（即 arr[length-2]）。
// 通过这种方式，每次外部循环结束后，已排序部分的长度会增加 1，而内部循环中无需再考虑已经排序好的部分。

// 在内部循环中，只需要比较和交换前 length-i-1 个元素，确保最大的 length-i 个元素已经排好序，而无需再对已排序部分进行操作。
// 这就是为什么内部循环条件应为 j < length-i-1 的原因。

// 使用 length-i-1 作为内部循环的边界条件，可以有效地减少不必要的比较和交换操作，提高算法的效率。
// 这是冒泡排序算法的核心思想之一。
